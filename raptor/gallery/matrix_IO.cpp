#include "matrix_IO.hpp"
#include <float.h>

ParMatrix* readParMatrix(char* filename, MPI_Comm comm, bool single_file, index_t symmetric = 1)
{
    index_t num_rows, num_cols, nnz, comm_size, rank, ret_code;
    index_t* row_ptr;
    index_t* col;
    data_t* data;
    index_t* global_row_starts;
    
    if (single_file) 
    {
        MM_typecode matcode;
        FILE* infile;
        
        MPI_Comm_size(comm, &comm_size);
        MPI_Comm_rank(comm, &rank);

        for (index_t proc = 0; proc < comm_size; proc++)
        {
            if (rank == proc)
            {
                // find size of matix 
                if ((infile = fopen(filename, "r")) == NULL) 
                    return NULL;

                if (mm_read_banner(infile, &matcode) != 0)
                    return NULL;

                if ((ret_code = mm_read_mtx_crd_size(infile, &num_rows, &num_cols, &nnz)) !=0)
                    return NULL;
        
                fclose(infile);
                //create a partintioning
                index_t extra = num_rows % comm_size;
                global_row_starts = new index_t[comm_size+1];
                global_row_starts[0] = 0;
                for (int i = 0; i < comm_size; i++)
                {
                    global_row_starts[i+1] =  global_row_starts[i] + (num_rows/comm_size);
                    if (i < extra)
                    {
                        global_row_starts[i+1]++;
                    }
                }
    
                // read the file knowing our local rows
                ret_code = mm_read_sparse(filename, global_row_starts[rank],
                    global_row_starts[rank+1], &num_rows, &num_cols, &nnz,
                    &data, &row_ptr, &col, symmetric);

                if (ret_code != 0)
                {
                    delete[] global_row_starts; 
                    return NULL;
                }
            }
            MPI_Barrier(MPI_COMM_WORLD);
        }
    }
    else //one file per MPI process
    {
        //TODO: init global_row_starts
        global_row_starts = new index_t[comm_size+1];
        
        ret_code = mm_read_sparse(filename, global_row_starts[rank],
                    global_row_starts[rank+1], &num_rows, &num_cols, &nnz,
                    &data, &row_ptr, &col, symmetric);
        if (ret_code != 0)
        {
            delete[] global_row_starts; 
            return NULL;
        }
    }

    //printf("GlobRowStarts[%d] = %d\t RowEnds[%d] = %d\tNNZ=%d\n", rank, global_row_starts[rank], rank, global_row_starts[rank+1], nnz);

    return new ParMatrix(num_rows, num_cols, nnz, row_ptr, col, data,
                global_row_starts, COO, 1, symmetric);
}

int mm_read_sparse(const char *fname, int start, int stop, int *M_, int *N_, int *nz_,
                double **val_, int **I_, int **J_, int symmetric)
{
    FILE *f;
    MM_typecode matcode;
    int M, N, nz;
    int i, ctr;
    double *val;
    int *I, *J;
    data_t zero_tol = DBL_EPSILON;
     
    if ((f = fopen(fname, "r")) == NULL)
            return -1;
 
 
    if (mm_read_banner(f, &matcode) != 0)
    {
        printf("mm_read_unsymetric: Could not process Matrix Market banner ");
        printf(" in file [%s]\n", fname);
        return -1;
    }
 
 
 
    if ( !(mm_is_real(matcode) && mm_is_matrix(matcode) &&
            mm_is_sparse(matcode)))
    {
        fprintf(stderr, "Sorry, this application does not support ");
        fprintf(stderr, "Market Market type: [%s]\n",
                mm_typecode_to_str(matcode));
        return -1;
    }
 
    /* find out size of sparse matrix: M, N, nz .... */
 
    if (mm_read_mtx_crd_size(f, &M, &N, &nz) !=0)
    {
        fprintf(stderr, "read_unsymmetric_sparse(): could not parse matrix size.\n");
        return -1;
    }
 
    *M_ = M;
    *N_ = N;
    //*nz_ = nz;
 
    /* reseve memory for matrices */
 
    if (symmetric)
    {
        I = (int *) malloc(2*nz * sizeof(int));
        J = (int *) malloc(2*nz * sizeof(int));
        val = (double *) malloc(2*nz * sizeof(double));
    }
    else
    {
        I = (int *) malloc(nz * sizeof(int));
        J = (int *) malloc(nz * sizeof(int));
        val = (double *) malloc(nz * sizeof(double));
    }
 
    *val_ = val;
    *I_ = I;
    *J_ = J;
 
    /* NOTE: when reading in doubles, ANSI C requires the use of the "l"  */
    /*   specifier as in "%lg", "%lf", "%le", otherwise errors will occur */
    /*  (ANSI C X3.159-1989, Sec. 4.9.6.2, p. 136 lines 13-15)            */

    ctr = 0;
    for (i=0; i<nz; i++)
    {
        fscanf(f, "%d %d %lg\n", &I[ctr], &J[ctr], &val[ctr]);
        index_t row = I[ctr];
        index_t col = J[ctr];
        data_t value = val[ctr];
        if (fabs(value) < zero_tol) continue;

        if (row > start && row <= stop)
        {
            I[ctr] = row-1;  /* adjust from 1-based to 0-based */
            J[ctr] = col-1;
            val[ctr] = value;
            if (fabs(value) < 1e-16) printf("Value %d < zerotol!\n", ctr);
            //printf("(%d, %d) - %2.3e\tctr=%d\n", row-1, col-1, value, ctr);
            ctr++;
        }
        if (symmetric && col > start && col <= stop && col != row)
        {
            I[ctr] = col-1;
            J[ctr] = row-1;
            val[ctr] = value;
            //printf("(%d, %d) - %2.3e\tctr=%d\n", col-1, row-1, value, ctr);
            ctr++;
        }
    }
    fclose(f);
    *nz_ = ctr;
    return 0;
}


int mm_is_valid(MM_typecode matcode)
{
    if (!mm_is_matrix(matcode)) return 0;
    if (mm_is_dense(matcode) && mm_is_pattern(matcode)) return 0;
    if (mm_is_real(matcode) && mm_is_hermitian(matcode)) return 0;
    if (mm_is_pattern(matcode) && (mm_is_hermitian(matcode) || 
                mm_is_skew(matcode))) return 0;
    return 1;
}

int mm_read_banner(FILE *f, MM_typecode *matcode)
{
    char line[MM_MAX_LINE_LENGTH];
    char banner[MM_MAX_TOKEN_LENGTH];
    char mtx[MM_MAX_TOKEN_LENGTH]; 
    char crd[MM_MAX_TOKEN_LENGTH];
    char data_type[MM_MAX_TOKEN_LENGTH];
    char storage_scheme[MM_MAX_TOKEN_LENGTH];
    char *p;


    mm_clear_typecode(matcode);  

    if (fgets(line, MM_MAX_LINE_LENGTH, f) == NULL) 
        return MM_PREMATURE_EOF;

    if (sscanf(line, "%s %s %s %s %s", banner, mtx, crd, data_type, 
        storage_scheme) != 5)
        return MM_PREMATURE_EOF;

    for (p=mtx; *p!='\0'; *p=tolower(*p),p++);  /* convert to lower case */
    for (p=crd; *p!='\0'; *p=tolower(*p),p++);  
    for (p=data_type; *p!='\0'; *p=tolower(*p),p++);
    for (p=storage_scheme; *p!='\0'; *p=tolower(*p),p++);

    /* check for banner */
    if (strncmp(banner, MatrixMarketBanner, strlen(MatrixMarketBanner)) != 0)
        return MM_NO_HEADER;

    /* first field should be "mtx" */
    if (strcmp(mtx, MM_MTX_STR) != 0)
        return  MM_UNSUPPORTED_TYPE;
    mm_set_matrix(matcode);


    /* second field describes whether this is a sparse matrix (in coordinate
            storgae) or a dense array */


    if (strcmp(crd, MM_SPARSE_STR) == 0)
        mm_set_sparse(matcode);
    else
    if (strcmp(crd, MM_DENSE_STR) == 0)
            mm_set_dense(matcode);
    else
        return MM_UNSUPPORTED_TYPE;
    

    /* third field */

    if (strcmp(data_type, MM_REAL_STR) == 0)
        mm_set_real(matcode);
    else
    if (strcmp(data_type, MM_COMPLEX_STR) == 0)
        mm_set_complex(matcode);
    else
    if (strcmp(data_type, MM_PATTERN_STR) == 0)
        mm_set_pattern(matcode);
    else
    if (strcmp(data_type, MM_INT_STR) == 0)
        mm_set_integer(matcode);
    else
        return MM_UNSUPPORTED_TYPE;
    

    /* fourth field */

    if (strcmp(storage_scheme, MM_GENERAL_STR) == 0)
        mm_set_general(matcode);
    else
    if (strcmp(storage_scheme, MM_SYMM_STR) == 0)
        mm_set_symmetric(matcode);
    else
    if (strcmp(storage_scheme, MM_HERM_STR) == 0)
        mm_set_hermitian(matcode);
    else
    if (strcmp(storage_scheme, MM_SKEW_STR) == 0)
        mm_set_skew(matcode);
    else
        return MM_UNSUPPORTED_TYPE;
        

    return 0;
}

int mm_write_mtx_crd_size(FILE *f, int M, int N, int nz)
{
    if (fprintf(f, "%d %d %d\n", M, N, nz) != 3)
        return MM_COULD_NOT_WRITE_FILE;
    else 
        return 0;
}

int mm_read_mtx_crd_size(FILE *f, int *M, int *N, int *nz )
{
    char line[MM_MAX_LINE_LENGTH];
    int num_items_read;

    /* set return null parameter values, in case we exit with errors */
    *M = *N = *nz = 0;

    /* now continue scanning until you reach the end-of-comments */
    do 
    {
        if (fgets(line,MM_MAX_LINE_LENGTH,f) == NULL) 
            return MM_PREMATURE_EOF;
    }while (line[0] == '%');

    /* line[] is either blank or has M,N, nz */
    if (sscanf(line, "%d %d %d", M, N, nz) == 3)
        return 0;
        
    else
    do
    { 
        num_items_read = fscanf(f, "%d %d %d", M, N, nz); 
        if (num_items_read == EOF) return MM_PREMATURE_EOF;
    }
    while (num_items_read != 3);

    return 0;
}


int mm_read_mtx_array_size(FILE *f, int *M, int *N)
{
    char line[MM_MAX_LINE_LENGTH];
    int num_items_read;
    /* set return null parameter values, in case we exit with errors */
    *M = *N = 0;
	
    /* now continue scanning until you reach the end-of-comments */
    do 
    {
        if (fgets(line,MM_MAX_LINE_LENGTH,f) == NULL) 
            return MM_PREMATURE_EOF;
    }while (line[0] == '%');

    /* line[] is either blank or has M,N, nz */
    if (sscanf(line, "%d %d", M, N) == 2)
        return 0;
        
    else /* we have a blank line */
    do
    { 
        num_items_read = fscanf(f, "%d %d", M, N); 
        if (num_items_read == EOF) return MM_PREMATURE_EOF;
    }
    while (num_items_read != 2);

    return 0;
}

int mm_write_mtx_array_size(FILE *f, int M, int N)
{
    if (fprintf(f, "%d %d\n", M, N) != 2)
        return MM_COULD_NOT_WRITE_FILE;
    else 
        return 0;
}

char *mm_strdup(const char *s)
{
	int len = strlen(s);
	char *s2 = (char *) malloc((len+1)*sizeof(char));
	return strcpy(s2, s);
}

char  *mm_typecode_to_str(MM_typecode matcode)
{
    char buffer[MM_MAX_LINE_LENGTH];
    char const *types[4];
	char *mm_strdup(const char *);

    /* check for MTX type */
    if (mm_is_matrix(matcode)) 
        types[0] = MM_MTX_STR;

    /* check for CRD or ARR matrix */
    if (mm_is_sparse(matcode))
        types[1] = MM_SPARSE_STR;
    else
    if (mm_is_dense(matcode))
        types[1] = MM_DENSE_STR;
    else
        return NULL;

    /* check for element data type */
    if (mm_is_real(matcode))
        types[2] = MM_REAL_STR;
    else
    if (mm_is_complex(matcode))
        types[2] = MM_COMPLEX_STR;
    else
    if (mm_is_pattern(matcode))
        types[2] = MM_PATTERN_STR;
    else
    if (mm_is_integer(matcode))
        types[2] = MM_INT_STR;
    else
        return NULL;


    /* check for symmetry type */
    if (mm_is_general(matcode))
        types[3] = MM_GENERAL_STR;
    else
    if (mm_is_symmetric(matcode))
        types[3] = MM_SYMM_STR;
    else 
    if (mm_is_hermitian(matcode))
        types[3] = MM_HERM_STR;
    else 
    if (mm_is_skew(matcode))
        types[3] = MM_SKEW_STR;
    else
        return NULL;

    sprintf(buffer,"%s %s %s %s", types[0], types[1], types[2], types[3]);
    return mm_strdup(buffer);

}
